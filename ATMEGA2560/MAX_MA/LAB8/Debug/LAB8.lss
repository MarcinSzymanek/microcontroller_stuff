
LAB8.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001a8  00800200  0000077a  0000080e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000077a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000015  008003a8  008003a8  000009b6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000009b6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000009e8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000100  00000000  00000000  00000a28  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001bf3  00000000  00000000  00000b28  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000dac  00000000  00000000  0000271b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b02  00000000  00000000  000034c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001e8  00000000  00000000  00003fcc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000073d  00000000  00000000  000041b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000041a  00000000  00000000  000048f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e0  00000000  00000000  00004d0b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	7d c0       	rjmp	.+250    	; 0xfc <__ctors_end>
   2:	00 00       	nop
   4:	9a c0       	rjmp	.+308    	; 0x13a <__bad_interrupt>
   6:	00 00       	nop
   8:	98 c0       	rjmp	.+304    	; 0x13a <__bad_interrupt>
   a:	00 00       	nop
   c:	96 c0       	rjmp	.+300    	; 0x13a <__bad_interrupt>
   e:	00 00       	nop
  10:	94 c0       	rjmp	.+296    	; 0x13a <__bad_interrupt>
  12:	00 00       	nop
  14:	92 c0       	rjmp	.+292    	; 0x13a <__bad_interrupt>
  16:	00 00       	nop
  18:	90 c0       	rjmp	.+288    	; 0x13a <__bad_interrupt>
  1a:	00 00       	nop
  1c:	8e c0       	rjmp	.+284    	; 0x13a <__bad_interrupt>
  1e:	00 00       	nop
  20:	8c c0       	rjmp	.+280    	; 0x13a <__bad_interrupt>
  22:	00 00       	nop
  24:	8a c0       	rjmp	.+276    	; 0x13a <__bad_interrupt>
  26:	00 00       	nop
  28:	88 c0       	rjmp	.+272    	; 0x13a <__bad_interrupt>
  2a:	00 00       	nop
  2c:	86 c0       	rjmp	.+268    	; 0x13a <__bad_interrupt>
  2e:	00 00       	nop
  30:	84 c0       	rjmp	.+264    	; 0x13a <__bad_interrupt>
  32:	00 00       	nop
  34:	82 c0       	rjmp	.+260    	; 0x13a <__bad_interrupt>
  36:	00 00       	nop
  38:	80 c0       	rjmp	.+256    	; 0x13a <__bad_interrupt>
  3a:	00 00       	nop
  3c:	7e c0       	rjmp	.+252    	; 0x13a <__bad_interrupt>
  3e:	00 00       	nop
  40:	7c c0       	rjmp	.+248    	; 0x13a <__bad_interrupt>
  42:	00 00       	nop
  44:	7a c0       	rjmp	.+244    	; 0x13a <__bad_interrupt>
  46:	00 00       	nop
  48:	78 c0       	rjmp	.+240    	; 0x13a <__bad_interrupt>
  4a:	00 00       	nop
  4c:	76 c0       	rjmp	.+236    	; 0x13a <__bad_interrupt>
  4e:	00 00       	nop
  50:	74 c0       	rjmp	.+232    	; 0x13a <__bad_interrupt>
  52:	00 00       	nop
  54:	72 c0       	rjmp	.+228    	; 0x13a <__bad_interrupt>
  56:	00 00       	nop
  58:	70 c0       	rjmp	.+224    	; 0x13a <__bad_interrupt>
  5a:	00 00       	nop
  5c:	6e c0       	rjmp	.+220    	; 0x13a <__bad_interrupt>
  5e:	00 00       	nop
  60:	6c c0       	rjmp	.+216    	; 0x13a <__bad_interrupt>
  62:	00 00       	nop
  64:	6a c0       	rjmp	.+212    	; 0x13a <__bad_interrupt>
  66:	00 00       	nop
  68:	68 c0       	rjmp	.+208    	; 0x13a <__bad_interrupt>
  6a:	00 00       	nop
  6c:	66 c0       	rjmp	.+204    	; 0x13a <__bad_interrupt>
  6e:	00 00       	nop
  70:	64 c0       	rjmp	.+200    	; 0x13a <__bad_interrupt>
  72:	00 00       	nop
  74:	62 c0       	rjmp	.+196    	; 0x13a <__bad_interrupt>
  76:	00 00       	nop
  78:	60 c0       	rjmp	.+192    	; 0x13a <__bad_interrupt>
  7a:	00 00       	nop
  7c:	5e c0       	rjmp	.+188    	; 0x13a <__bad_interrupt>
  7e:	00 00       	nop
  80:	5c c0       	rjmp	.+184    	; 0x13a <__bad_interrupt>
  82:	00 00       	nop
  84:	5a c0       	rjmp	.+180    	; 0x13a <__bad_interrupt>
  86:	00 00       	nop
  88:	58 c0       	rjmp	.+176    	; 0x13a <__bad_interrupt>
  8a:	00 00       	nop
  8c:	56 c0       	rjmp	.+172    	; 0x13a <__bad_interrupt>
  8e:	00 00       	nop
  90:	54 c0       	rjmp	.+168    	; 0x13a <__bad_interrupt>
  92:	00 00       	nop
  94:	52 c0       	rjmp	.+164    	; 0x13a <__bad_interrupt>
  96:	00 00       	nop
  98:	50 c0       	rjmp	.+160    	; 0x13a <__bad_interrupt>
  9a:	00 00       	nop
  9c:	4e c0       	rjmp	.+156    	; 0x13a <__bad_interrupt>
  9e:	00 00       	nop
  a0:	4c c0       	rjmp	.+152    	; 0x13a <__bad_interrupt>
  a2:	00 00       	nop
  a4:	4a c0       	rjmp	.+148    	; 0x13a <__bad_interrupt>
  a6:	00 00       	nop
  a8:	48 c0       	rjmp	.+144    	; 0x13a <__bad_interrupt>
  aa:	00 00       	nop
  ac:	46 c0       	rjmp	.+140    	; 0x13a <__bad_interrupt>
  ae:	00 00       	nop
  b0:	44 c0       	rjmp	.+136    	; 0x13a <__bad_interrupt>
  b2:	00 00       	nop
  b4:	42 c0       	rjmp	.+132    	; 0x13a <__bad_interrupt>
  b6:	00 00       	nop
  b8:	40 c0       	rjmp	.+128    	; 0x13a <__bad_interrupt>
  ba:	00 00       	nop
  bc:	3e c0       	rjmp	.+124    	; 0x13a <__bad_interrupt>
  be:	00 00       	nop
  c0:	3c c0       	rjmp	.+120    	; 0x13a <__bad_interrupt>
  c2:	00 00       	nop
  c4:	3a c0       	rjmp	.+116    	; 0x13a <__bad_interrupt>
  c6:	00 00       	nop
  c8:	38 c0       	rjmp	.+112    	; 0x13a <__bad_interrupt>
  ca:	00 00       	nop
  cc:	36 c0       	rjmp	.+108    	; 0x13a <__bad_interrupt>
  ce:	00 00       	nop
  d0:	34 c0       	rjmp	.+104    	; 0x13a <__bad_interrupt>
  d2:	00 00       	nop
  d4:	32 c0       	rjmp	.+100    	; 0x13a <__bad_interrupt>
  d6:	00 00       	nop
  d8:	30 c0       	rjmp	.+96     	; 0x13a <__bad_interrupt>
  da:	00 00       	nop
  dc:	2e c0       	rjmp	.+92     	; 0x13a <__bad_interrupt>
  de:	00 00       	nop
  e0:	2c c0       	rjmp	.+88     	; 0x13a <__bad_interrupt>
  e2:	00 00       	nop
  e4:	a8 02       	muls	r26, r24
  e6:	a5 02       	muls	r26, r21
  e8:	b5 02       	muls	r27, r21
  ea:	a2 02       	muls	r26, r18
  ec:	b5 02       	muls	r27, r21
  ee:	b2 02       	muls	r27, r18
  f0:	a0 02       	muls	r26, r16
  f2:	b5 02       	muls	r27, r21
  f4:	ae 02       	muls	r26, r30
  f6:	b0 02       	muls	r27, r16
  f8:	ac 02       	muls	r26, r28
  fa:	aa 02       	muls	r26, r26

000000fc <__ctors_end>:
  fc:	11 24       	eor	r1, r1
  fe:	1f be       	out	0x3f, r1	; 63
 100:	cf ef       	ldi	r28, 0xFF	; 255
 102:	d1 e2       	ldi	r29, 0x21	; 33
 104:	de bf       	out	0x3e, r29	; 62
 106:	cd bf       	out	0x3d, r28	; 61
 108:	00 e0       	ldi	r16, 0x00	; 0
 10a:	0c bf       	out	0x3c, r16	; 60

0000010c <__do_copy_data>:
 10c:	13 e0       	ldi	r17, 0x03	; 3
 10e:	a0 e0       	ldi	r26, 0x00	; 0
 110:	b2 e0       	ldi	r27, 0x02	; 2
 112:	ea e7       	ldi	r30, 0x7A	; 122
 114:	f7 e0       	ldi	r31, 0x07	; 7
 116:	00 e0       	ldi	r16, 0x00	; 0
 118:	0b bf       	out	0x3b, r16	; 59
 11a:	02 c0       	rjmp	.+4      	; 0x120 <__do_copy_data+0x14>
 11c:	07 90       	elpm	r0, Z+
 11e:	0d 92       	st	X+, r0
 120:	a8 3a       	cpi	r26, 0xA8	; 168
 122:	b1 07       	cpc	r27, r17
 124:	d9 f7       	brne	.-10     	; 0x11c <__do_copy_data+0x10>

00000126 <__do_clear_bss>:
 126:	23 e0       	ldi	r18, 0x03	; 3
 128:	a8 ea       	ldi	r26, 0xA8	; 168
 12a:	b3 e0       	ldi	r27, 0x03	; 3
 12c:	01 c0       	rjmp	.+2      	; 0x130 <.do_clear_bss_start>

0000012e <.do_clear_bss_loop>:
 12e:	1d 92       	st	X+, r1

00000130 <.do_clear_bss_start>:
 130:	ad 3b       	cpi	r26, 0xBD	; 189
 132:	b2 07       	cpc	r27, r18
 134:	e1 f7       	brne	.-8      	; 0x12e <.do_clear_bss_loop>
 136:	e4 d2       	rcall	.+1480   	; 0x700 <main>
 138:	1e c3       	rjmp	.+1596   	; 0x776 <_exit>

0000013a <__bad_interrupt>:
 13a:	62 cf       	rjmp	.-316    	; 0x0 <__vectors>

0000013c <initSPI>:
unsigned char send3zeros;        // EP3-IN function uses this to send HID (key up) codes between keystrokes

void initSPI()
{
  // MOSI, CLK and SS pins + MAX CS are output 
  DDRB |= 0b00010111;
 13c:	84 b1       	in	r24, 0x04	; 4
 13e:	87 61       	ori	r24, 0x17	; 23
 140:	84 b9       	out	0x04, r24	; 4
  // MISO pin is input
  DDRB &= 0b11110111;
 142:	84 b1       	in	r24, 0x04	; 4
 144:	87 7f       	andi	r24, 0xF7	; 247
 146:	84 b9       	out	0x04, r24	; 4
  // At Mega2560: MAX Select is at PB4
  // SS high (deselect MAX)
  PORTB |= 0b00010001;
 148:	85 b1       	in	r24, 0x05	; 5
 14a:	81 61       	ori	r24, 0x11	; 17
 14c:	85 b9       	out	0x05, r24	; 5
  // Disable SPI interrupts, SPI enable, MSB first, Master, Mode(0,0), f = 125 kHz
  SPCR = 0b01010011;
 14e:	83 e5       	ldi	r24, 0x53	; 83
 150:	8c bd       	out	0x2c, r24	; 44
  SPSR = 0;  
 152:	1d bc       	out	0x2d, r1	; 45
 154:	08 95       	ret

00000156 <wreg>:
// Write a MAX3420E register byte
void wreg(unsigned char reg, unsigned char dat)
{
unsigned char dummy;	
  // Slave select (MAX SS low)
  PORTB &= 0b11101111;
 156:	95 b1       	in	r25, 0x05	; 5
 158:	9f 7e       	andi	r25, 0xEF	; 239
 15a:	95 b9       	out	0x05, r25	; 5
  // Send the register number with the DIR bit (b1) set to WRITE
  SPDR = reg | 0b00000010;
 15c:	82 60       	ori	r24, 0x02	; 2
 15e:	8e bd       	out	0x2e, r24	; 46
  // Await transfer complete
  while ((SPSR & 0b10000000) == 0)
 160:	0d b4       	in	r0, 0x2d	; 45
 162:	07 fe       	sbrs	r0, 7
 164:	fd cf       	rjmp	.-6      	; 0x160 <wreg+0xa>
  {}
  // Clear SPIF	  
  dummy = SPDR;	    
 166:	8e b5       	in	r24, 0x2e	; 46
  // Send the data
  SPDR = dat;
 168:	6e bd       	out	0x2e, r22	; 46
  // Await transfer complete
  while ((SPSR & 0b10000000) == 0)
 16a:	0d b4       	in	r0, 0x2d	; 45
 16c:	07 fe       	sbrs	r0, 7
 16e:	fd cf       	rjmp	.-6      	; 0x16a <wreg+0x14>
  {}
  // Clear SPIF
  dummy = SPDR;
 170:	8e b5       	in	r24, 0x2e	; 46
  // Slave deselect (MAX SS high)
  PORTB |= 0b00010000;
 172:	85 b1       	in	r24, 0x05	; 5
 174:	80 61       	ori	r24, 0x10	; 16
 176:	85 b9       	out	0x05, r24	; 5
 178:	08 95       	ret

0000017a <wregAS>:
// Same as 'wreg' but also set the ACKSTAT bit in the SPI command byte
void wregAS(unsigned char reg, unsigned char dat)
{
unsigned char dummy;
  // Slave select (MAX SS low)
  PORTB &= 0b11101111;
 17a:	95 b1       	in	r25, 0x05	; 5
 17c:	9f 7e       	andi	r25, 0xEF	; 239
 17e:	95 b9       	out	0x05, r25	; 5
  // Send the register number with the DIR bit (b1) set to WRITE and bit 0 (ACK STATUS) set to 1
  SPDR = reg | 0b00000011;
 180:	83 60       	ori	r24, 0x03	; 3
 182:	8e bd       	out	0x2e, r24	; 46
  // Await transfer complete
  while ((SPSR & 0b10000000) == 0)
 184:	0d b4       	in	r0, 0x2d	; 45
 186:	07 fe       	sbrs	r0, 7
 188:	fd cf       	rjmp	.-6      	; 0x184 <wregAS+0xa>
  {}
  // Clear SPIF
  dummy = SPDR;
 18a:	8e b5       	in	r24, 0x2e	; 46
  // Send the data
  SPDR = dat;
 18c:	6e bd       	out	0x2e, r22	; 46
  // Await transfer complete
  while ((SPSR & 0b10000000) == 0)
 18e:	0d b4       	in	r0, 0x2d	; 45
 190:	07 fe       	sbrs	r0, 7
 192:	fd cf       	rjmp	.-6      	; 0x18e <wregAS+0x14>
  {}
  // Clear SPIF
  dummy = SPDR;
 194:	8e b5       	in	r24, 0x2e	; 46
  // Slave deselect (MAX SS high)
  PORTB |= 0b00010000;
 196:	85 b1       	in	r24, 0x05	; 5
 198:	80 61       	ori	r24, 0x10	; 16
 19a:	85 b9       	out	0x05, r24	; 5
 19c:	08 95       	ret

0000019e <rreg>:
// Read a register, return its value.
unsigned char rreg(unsigned char reg)
{
unsigned char dummy;	
  // Slave select (MAX SS low)
  PORTB &= 0b11101111;
 19e:	95 b1       	in	r25, 0x05	; 5
 1a0:	9f 7e       	andi	r25, 0xEF	; 239
 1a2:	95 b9       	out	0x05, r25	; 5
  // Send the register number with the DIR bit (b1) reset to READ
  SPDR = reg;
 1a4:	8e bd       	out	0x2e, r24	; 46
  // Await transfer complete
  while ((SPSR & 0b10000000) == 0)
 1a6:	0d b4       	in	r0, 0x2d	; 45
 1a8:	07 fe       	sbrs	r0, 7
 1aa:	fd cf       	rjmp	.-6      	; 0x1a6 <rreg+0x8>
  {}
  // Clear SPIF
  dummy = SPDR;
 1ac:	8e b5       	in	r24, 0x2e	; 46
  // Dummy send (generate 8 clocks)
  SPDR = 0;
 1ae:	1e bc       	out	0x2e, r1	; 46
  // Await transfer complete  
  while ((SPSR & 0b10000000) == 0)
 1b0:	0d b4       	in	r0, 0x2d	; 45
 1b2:	07 fe       	sbrs	r0, 7
 1b4:	fd cf       	rjmp	.-6      	; 0x1b0 <rreg+0x12>
  {}  
  // Slave deselect (MAX SS high)
  PORTB |= 0b00010000;
 1b6:	85 b1       	in	r24, 0x05	; 5
 1b8:	80 61       	ori	r24, 0x10	; 16
 1ba:	85 b9       	out	0x05, r24	; 5
  // Return read data
  return SPDR;  
 1bc:	8e b5       	in	r24, 0x2e	; 46
}
 1be:	08 95       	ret

000001c0 <rregAS>:
// Same as 'rreg' but also set the ACKSTAT bit
unsigned char rregAS(unsigned char reg)
{
unsigned char dummy;
  // Slave select (MAX SS low)
  PORTB &= 0b11101111;
 1c0:	95 b1       	in	r25, 0x05	; 5
 1c2:	9f 7e       	andi	r25, 0xEF	; 239
 1c4:	95 b9       	out	0x05, r25	; 5
  // Send the register number with the DIR bit (b1) reset to READ and bit 0 (ACKSTAT) set to 1
  SPDR = reg | 0b00000001;
 1c6:	81 60       	ori	r24, 0x01	; 1
 1c8:	8e bd       	out	0x2e, r24	; 46
  // Await transfer complete
  while ((SPSR & 0b10000000) == 0)
 1ca:	0d b4       	in	r0, 0x2d	; 45
 1cc:	07 fe       	sbrs	r0, 7
 1ce:	fd cf       	rjmp	.-6      	; 0x1ca <rregAS+0xa>
  {}
  // Clear SPIF
  dummy = SPDR;
 1d0:	8e b5       	in	r24, 0x2e	; 46
  // Dummy send (generate 8 clocks)
  SPDR = 0;
 1d2:	1e bc       	out	0x2e, r1	; 46
  // Await transfer complete
  while ((SPSR & 0b10000000) == 0)
 1d4:	0d b4       	in	r0, 0x2d	; 45
 1d6:	07 fe       	sbrs	r0, 7
 1d8:	fd cf       	rjmp	.-6      	; 0x1d4 <rregAS+0x14>
  {}
  // Slave deselect (MAX SS high)
  PORTB |= 0b00010000;
 1da:	85 b1       	in	r24, 0x05	; 5
 1dc:	80 61       	ori	r24, 0x10	; 16
 1de:	85 b9       	out	0x05, r24	; 5
  // Return read data
  return SPDR;
 1e0:	8e b5       	in	r24, 0x2e	; 46
}
 1e2:	08 95       	ret

000001e4 <readbytes>:

// Read N MAX3420E FIFO bytes into the array p
void readbytes(unsigned char reg, unsigned char N, unsigned char *p)
{
 1e4:	fa 01       	movw	r30, r20
unsigned char j;
  // Slave select (MAX SS low)
  PORTB &= 0b11101111;
 1e6:	95 b1       	in	r25, 0x05	; 5
 1e8:	9f 7e       	andi	r25, 0xEF	; 239
 1ea:	95 b9       	out	0x05, r25	; 5
  // Send the register number with the DIR bit (b1) reset to READ
  SPDR = reg;
 1ec:	8e bd       	out	0x2e, r24	; 46
  // Await transfer complete
  while ((SPSR & 0b10000000) == 0)
 1ee:	0d b4       	in	r0, 0x2d	; 45
 1f0:	07 fe       	sbrs	r0, 7
 1f2:	fd cf       	rjmp	.-6      	; 0x1ee <readbytes+0xa>
  {}  
  // Clear SPIF
  j = SPDR;  
 1f4:	8e b5       	in	r24, 0x2e	; 46
  for(j=0; j<N; j++)
 1f6:	80 e0       	ldi	r24, 0x00	; 0
 1f8:	07 c0       	rjmp	.+14     	; 0x208 <readbytes+0x24>
  {
    // Dummy send (generate 8 clocks)
    SPDR = 0;
 1fa:	1e bc       	out	0x2e, r1	; 46
    // Await transfer complete
    while ((SPSR & 0b10000000) == 0)
 1fc:	0d b4       	in	r0, 0x2d	; 45
 1fe:	07 fe       	sbrs	r0, 7
 200:	fd cf       	rjmp	.-6      	; 0x1fc <readbytes+0x18>
    {}
    // store it in the data array   	
    *p = SPDR;
 202:	9e b5       	in	r25, 0x2e	; 46
 204:	91 93       	st	Z+, r25
  // Await transfer complete
  while ((SPSR & 0b10000000) == 0)
  {}  
  // Clear SPIF
  j = SPDR;  
  for(j=0; j<N; j++)
 206:	8f 5f       	subi	r24, 0xFF	; 255
 208:	86 17       	cp	r24, r22
 20a:	b8 f3       	brcs	.-18     	; 0x1fa <readbytes+0x16>
    // store it in the data array   	
    *p = SPDR;
	p++;
  }
  // Slave deselect (MAX SS high)
  PORTB |= 0b00010000;
 20c:	85 b1       	in	r24, 0x05	; 5
 20e:	80 61       	ori	r24, 0x10	; 16
 210:	85 b9       	out	0x05, r24	; 5
 212:	08 95       	ret

00000214 <writebytes>:
}

// Write N MAX3420E FIFO bytes into the array p
void writebytes(unsigned char reg, unsigned char N, const unsigned char *p)
{
 214:	fa 01       	movw	r30, r20
  // <------------- Write code here (exercise, part 2)
  
  // Slave select (MAX SS low)
  PORTB &= 0b11101111;
 216:	95 b1       	in	r25, 0x05	; 5
 218:	9f 7e       	andi	r25, 0xEF	; 239
 21a:	95 b9       	out	0x05, r25	; 5
  SPDR = reg | 0b00000010;
 21c:	82 60       	ori	r24, 0x02	; 2
 21e:	8e bd       	out	0x2e, r24	; 46
  while ((SPSR & 0b10000000) == 0)
 220:	0d b4       	in	r0, 0x2d	; 45
 222:	07 fe       	sbrs	r0, 7
 224:	fd cf       	rjmp	.-6      	; 0x220 <writebytes+0xc>
  {}
  // Read SPSR to clear IF flag
  char j = SPSR;
 226:	8d b5       	in	r24, 0x2d	; 45
  char dummy;
  for(j = 0; j < N; j++){
 228:	80 e0       	ldi	r24, 0x00	; 0
 22a:	09 c0       	rjmp	.+18     	; 0x23e <writebytes+0x2a>
	  // Clear SPIF
	  dummy = SPDR;
 22c:	9e b5       	in	r25, 0x2e	; 46
	  // Send the data
	  SPDR = *p;
 22e:	90 81       	ld	r25, Z
 230:	9e bd       	out	0x2e, r25	; 46
	  // Await transfer complete
	  while ((SPSR & 0b10000000) == 0)
 232:	0d b4       	in	r0, 0x2d	; 45
 234:	07 fe       	sbrs	r0, 7
 236:	fd cf       	rjmp	.-6      	; 0x232 <writebytes+0x1e>
	  {}
	  // Clear SPIF
	  dummy = SPDR;
 238:	9e b5       	in	r25, 0x2e	; 46
	  p++;
 23a:	31 96       	adiw	r30, 0x01	; 1
  while ((SPSR & 0b10000000) == 0)
  {}
  // Read SPSR to clear IF flag
  char j = SPSR;
  char dummy;
  for(j = 0; j < N; j++){
 23c:	8f 5f       	subi	r24, 0xFF	; 255
 23e:	86 17       	cp	r24, r22
 240:	a8 f3       	brcs	.-22     	; 0x22c <writebytes+0x18>
	  // Clear SPIF
	  dummy = SPDR;
	  p++;
  }
   // Slave deselect (MAX SS high)
   PORTB |= 0b00010000;
 242:	85 b1       	in	r24, 0x05	; 5
 244:	80 61       	ori	r24, 0x10	; 16
 246:	85 b9       	out	0x05, r24	; 5
 248:	08 95       	ret

0000024a <Reset_MAX>:

// Reset the MAX3420E
void Reset_MAX()
{
unsigned char dummy;
  wreg(rUSBCTL,0x20);	// chip reset
 24a:	60 e2       	ldi	r22, 0x20	; 32
 24c:	88 e7       	ldi	r24, 0x78	; 120
 24e:	83 df       	rcall	.-250    	; 0x156 <wreg>
  wreg(rUSBCTL,0x00);	// remove the reset
 250:	60 e0       	ldi	r22, 0x00	; 0
 252:	88 e7       	ldi	r24, 0x78	; 120
 254:	80 df       	rcall	.-256    	; 0x156 <wreg>
  do                  // Chip reset stops the oscillator. Wait for it to stabilize.
  {
    dummy = rreg(rUSBIRQ);
 256:	88 e6       	ldi	r24, 0x68	; 104
 258:	a2 df       	rcall	.-188    	; 0x19e <rreg>
 25a:	80 ff       	sbrs	r24, 0
	dummy &= bmOSCOKIRQ;
  }
  while (dummy == 0);
 25c:	fc cf       	rjmp	.-8      	; 0x256 <Reset_MAX+0xc>
 25e:	08 95       	ret

00000260 <EnableIRQs>:
}
 260:	60 e3       	ldi	r22, 0x30	; 48

void EnableIRQs()
{
  wreg(rEPIEN,(bmSUDAVIE+bmIN3BAVIE)); 
 262:	80 e6       	ldi	r24, 0x60	; 96
 264:	78 df       	rcall	.-272    	; 0x156 <wreg>
  wreg(rUSBIEN,(bmURESIE+bmURESDNIE));	
 266:	68 e8       	ldi	r22, 0x88	; 136
 268:	80 e7       	ldi	r24, 0x70	; 112
 26a:	75 cf       	rjmp	.-278    	; 0x156 <wreg>
 26c:	08 95       	ret

0000026e <initMAX3421>:
}

void initMAX3421()
{
  // Set global variables
  ep3stall=0;			// EP3 initially un-halted (no stall) (CH9 testing)
 26e:	10 92 ae 03 	sts	0x03AE, r1	; 0x8003ae <ep3stall>
  msgidx = 0;			// start of KB Message[]
 272:	10 92 ad 03 	sts	0x03AD, r1	; 0x8003ad <msgidx>
  msglen = sizeof(Message);     // so we can check for the end of the message
 276:	88 e4       	ldi	r24, 0x48	; 72
 278:	80 93 b8 03 	sts	0x03B8, r24	; 0x8003b8 <msglen>
  inhibit_send = 0x01;		// 0 means send, 1 means inhibit sending
 27c:	81 e0       	ldi	r24, 0x01	; 1
 27e:	80 93 bc 03 	sts	0x03BC, r24	; 0x8003bc <inhibit_send>
  send3zeros=1;
 282:	80 93 bb 03 	sts	0x03BB, r24	; 0x8003bb <send3zeros>
  msec_timer=0;
 286:	10 92 ba 03 	sts	0x03BA, r1	; 0x8003ba <msec_timer+0x1>
 28a:	10 92 b9 03 	sts	0x03B9, r1	; 0x8003b9 <msec_timer>
  blinktimer=0;
 28e:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <blinktimer+0x1>
 292:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <blinktimer>
  // software flags
  configval=0;                    // at pwr on OR bus reset we're unconfigured
 296:	10 92 ab 03 	sts	0x03AB, r1	; 0x8003ab <configval>
  Suspended=0;
 29a:	10 92 a8 03 	sts	0x03A8, r1	; 0x8003a8 <__data_end>
  RWU_enabled=0;                  // Set by host Set_Feature(enable RWU) request
 29e:	10 92 ac 03 	sts	0x03AC, r1	; 0x8003ac <RWU_enabled>
  // SPI initialization
  initSPI();
 2a2:	4c df       	rcall	.-360    	; 0x13c <initSPI>
  // Always set the FDUPSPI bit in the PINCTL register FIRST if you are using the SPI port in
  // full duplex mode. This configures the port properly for subsequent SPI accesses.
  wreg(rPINCTL,(bmFDUPSPI+bmINTLEVEL+gpxSOF)); // MAX3420: SPI=full-duplex, INT=neg level, GPX=SOF
 2a4:	6b e1       	ldi	r22, 0x1B	; 27
 2a6:	88 e8       	ldi	r24, 0x88	; 136
  Reset_MAX();
 2a8:	56 df       	rcall	.-340    	; 0x156 <wreg>
  wreg(rGPIO,0x00);                   // LEDs off (Active HIGH)
 2aa:	cf df       	rcall	.-98     	; 0x24a <Reset_MAX>
 2ac:	60 e0       	ldi	r22, 0x00	; 0
 2ae:	80 ea       	ldi	r24, 0xA0	; 160
  // Therefore set the VBGATE bit to have the MAX3420E automatically disconnect the D+
  // pullup resistor in the absense of Vbus. Note: the VBCOMP pin must be connected to Vbus
  // or pulled high for this code to work--a low on VBCOMP will prevent USB connection.

   // ----> wreg(rUSBCTL,(bmCONNECT+bmVBGATE));  // VBGATE=1 disconnects D+ pullup if host turns off VBUS
  wreg(rUSBCTL,(bmCONNECT));		// Alrøe: Just connect. The Vbus comparator pin is floating at the USB host shield!
 2b0:	52 df       	rcall	.-348    	; 0x156 <wreg>
 2b2:	68 e0       	ldi	r22, 0x08	; 8
 2b4:	88 e7       	ldi	r24, 0x78	; 120
  EnableIRQs();
 2b6:	4f df       	rcall	.-354    	; 0x156 <wreg>
 2b8:	d3 df       	rcall	.-90     	; 0x260 <EnableIRQs>
  wreg(rCPUCTL,bmIE);                 // Enable the INT pin  
 2ba:	61 e0       	ldi	r22, 0x01	; 1
 2bc:	80 e8       	ldi	r24, 0x80	; 128
 2be:	4b cf       	rjmp	.-362    	; 0x156 <wreg>
 2c0:	08 95       	ret

000002c2 <check_for_resume>:
 2c2:	88 e6       	ldi	r24, 0x68	; 104
}

void check_for_resume()
{
  if(rreg(rUSBIRQ) & bmBUSACTIRQ)     // THE HOST RESUMED BUS TRAFFIC
 2c4:	6c df       	rcall	.-296    	; 0x19e <rreg>
 2c6:	82 ff       	sbrs	r24, 2
 2c8:	09 c0       	rjmp	.+18     	; 0x2dc <check_for_resume+0x1a>
  {
    L2_OFF
 2ca:	80 ea       	ldi	r24, 0xA0	; 160
 2cc:	68 df       	rcall	.-304    	; 0x19e <rreg>
 2ce:	68 2f       	mov	r22, r24
 2d0:	6b 7f       	andi	r22, 0xFB	; 251
 2d2:	80 ea       	ldi	r24, 0xA0	; 160
 2d4:	40 df       	rcall	.-384    	; 0x156 <wreg>
	Suspended=0;                    // no longer suspended
 2d6:	10 92 a8 03 	sts	0x03A8, r1	; 0x8003a8 <__data_end>
 2da:	08 95       	ret
  }
  else if(RWU_enabled)                // Only if the host enabled RWU
 2dc:	80 91 ac 03 	lds	r24, 0x03AC	; 0x8003ac <RWU_enabled>
 2e0:	88 23       	and	r24, r24
  {
	if((rreg(rGPIO)&0x40)==0)       // See if the Remote Wakeup button was pressed
 2e2:	51 f1       	breq	.+84     	; 0x338 <check_for_resume+0x76>
 2e4:	80 ea       	ldi	r24, 0xA0	; 160
 2e6:	5b df       	rcall	.-330    	; 0x19e <rreg>
 2e8:	86 fd       	sbrc	r24, 6
	{
	  L2_OFF                        // turn off suspend light
 2ea:	26 c0       	rjmp	.+76     	; 0x338 <check_for_resume+0x76>
 2ec:	80 ea       	ldi	r24, 0xA0	; 160
 2ee:	57 df       	rcall	.-338    	; 0x19e <rreg>
 2f0:	68 2f       	mov	r22, r24
 2f2:	6b 7f       	andi	r22, 0xFB	; 251
 2f4:	80 ea       	ldi	r24, 0xA0	; 160
	  Suspended=0;                  // no longer suspended
 2f6:	2f df       	rcall	.-418    	; 0x156 <wreg>
	  SETBIT(rUSBCTL,bmSIGRWU)      // signal RWU
 2f8:	10 92 a8 03 	sts	0x03A8, r1	; 0x8003a8 <__data_end>
 2fc:	88 e7       	ldi	r24, 0x78	; 120
 2fe:	4f df       	rcall	.-354    	; 0x19e <rreg>
 300:	68 2f       	mov	r22, r24
 302:	64 60       	ori	r22, 0x04	; 4
	  while ((rreg(rUSBIRQ)&bmRWUDNIRQ)==0)  // spin until RWU signaling done
 304:	88 e7       	ldi	r24, 0x78	; 120
 306:	27 df       	rcall	.-434    	; 0x156 <wreg>
 308:	88 e6       	ldi	r24, 0x68	; 104
 30a:	49 df       	rcall	.-366    	; 0x19e <rreg>
	  {}	
	  CLRBIT(rUSBCTL,bmSIGRWU)      // remove the RESUME signal
 30c:	81 ff       	sbrs	r24, 1
 30e:	fc cf       	rjmp	.-8      	; 0x308 <check_for_resume+0x46>
 310:	88 e7       	ldi	r24, 0x78	; 120
 312:	45 df       	rcall	.-374    	; 0x19e <rreg>
 314:	68 2f       	mov	r22, r24
 316:	6b 7f       	andi	r22, 0xFB	; 251
	  wreg(rUSBIRQ,bmRWUDNIRQ);     // clear the IRQ
 318:	88 e7       	ldi	r24, 0x78	; 120
 31a:	1d df       	rcall	.-454    	; 0x156 <wreg>
 31c:	62 e0       	ldi	r22, 0x02	; 2
	  while((rreg(rGPIO)&0x40)==0)
 31e:	88 e6       	ldi	r24, 0x68	; 104
 320:	1a df       	rcall	.-460    	; 0x156 <wreg>
 322:	80 ea       	ldi	r24, 0xA0	; 160
 324:	3c df       	rcall	.-392    	; 0x19e <rreg>
 326:	86 ff       	sbrs	r24, 6
      {}  // hang until RWU button released
      wreg(rUSBIRQ,bmBUSACTIRQ);    // wait for bus traffic -- clear the BUS Active IRQ
 328:	fc cf       	rjmp	.-8      	; 0x322 <check_for_resume+0x60>
 32a:	64 e0       	ldi	r22, 0x04	; 4
 32c:	88 e6       	ldi	r24, 0x68	; 104
 32e:	13 df       	rcall	.-474    	; 0x156 <wreg>
      while((rreg(rUSBIRQ) & bmBUSACTIRQ)==0)
 330:	88 e6       	ldi	r24, 0x68	; 104
 332:	35 df       	rcall	.-406    	; 0x19e <rreg>
 334:	82 ff       	sbrs	r24, 2
 336:	fc cf       	rjmp	.-8      	; 0x330 <check_for_resume+0x6e>
 338:	08 95       	ret

0000033a <MAX_Int_Pending>:
 33a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__TEXT_REGION_LENGTH__+0x700100>

// Poll the MAX3420E INT pin (set for active low level)
unsigned char MAX_Int_Pending()
{
  // Henning Hargaard: The interrupt pin is connected to PORT H, pin 6
  return ((PINH & 0b01000000) == 0 );
 33e:	82 95       	swap	r24
 340:	86 95       	lsr	r24
 342:	86 95       	lsr	r24
 344:	83 70       	andi	r24, 0x03	; 3
 346:	91 e0       	ldi	r25, 0x01	; 1
 348:	89 27       	eor	r24, r25
}
 34a:	81 70       	andi	r24, 0x01	; 1
 34c:	08 95       	ret

0000034e <send_descriptor>:

void send_descriptor()
{
 34e:	cf 93       	push	r28
 350:	df 93       	push	r29
unsigned int reqlen,sendlen,desclen;
const unsigned char *pDdata;					// pointer to ROM Descriptor data to send
  //
  // NOTE This function assumes all descriptors are 64 or fewer bytes and can be sent in a single packet
  desclen = 0;					// check for zero as error condition (no case statements satisfied)
  reqlen = SUD[wLengthL] + 256*SUD[wLengthH];	// 16-bit
 352:	e0 eb       	ldi	r30, 0xB0	; 176
 354:	f3 e0       	ldi	r31, 0x03	; 3
 356:	26 81       	ldd	r18, Z+6	; 0x06
 358:	87 81       	ldd	r24, Z+7	; 0x07
 35a:	90 e0       	ldi	r25, 0x00	; 0
 35c:	98 2f       	mov	r25, r24
 35e:	88 27       	eor	r24, r24
 360:	82 0f       	add	r24, r18
 362:	91 1d       	adc	r25, r1
  switch (SUD[wValueH])			// wValueH is descriptor type
 364:	23 81       	ldd	r18, Z+3	; 0x03
 366:	23 30       	cpi	r18, 0x03	; 3
 368:	91 f0       	breq	.+36     	; 0x38e <send_descriptor+0x40>
 36a:	28 f4       	brcc	.+10     	; 0x376 <send_descriptor+0x28>
 36c:	21 30       	cpi	r18, 0x01	; 1
 36e:	31 f1       	breq	.+76     	; 0x3bc <send_descriptor+0x6e>
 370:	22 30       	cpi	r18, 0x02	; 2
 372:	41 f0       	breq	.+16     	; 0x384 <send_descriptor+0x36>
 374:	04 c0       	rjmp	.+8      	; 0x37e <send_descriptor+0x30>
 376:	21 32       	cpi	r18, 0x21	; 33
 378:	b9 f0       	breq	.+46     	; 0x3a8 <send_descriptor+0x5a>
 37a:	22 32       	cpi	r18, 0x22	; 34
 37c:	d1 f0       	breq	.+52     	; 0x3b2 <send_descriptor+0x64>
{
unsigned int reqlen,sendlen,desclen;
const unsigned char *pDdata;					// pointer to ROM Descriptor data to send
  //
  // NOTE This function assumes all descriptors are 64 or fewer bytes and can be sent in a single packet
  desclen = 0;					// check for zero as error condition (no case statements satisfied)
 37e:	60 e0       	ldi	r22, 0x00	; 0
 380:	70 e0       	ldi	r23, 0x00	; 0
 382:	20 c0       	rjmp	.+64     	; 0x3c4 <send_descriptor+0x76>
      desclen = DD[0];	// descriptor length
      pDdata = DD;
      break;
	case GD_CONFIGURATION:
	  desclen = CD[2];	// Config descriptor includes interface, HID, report and ep descriptors
      pDdata = CD;
 384:	43 e7       	ldi	r20, 0x73	; 115
 386:	53 e0       	ldi	r21, 0x03	; 3
	case GD_DEVICE:
      desclen = DD[0];	// descriptor length
      pDdata = DD;
      break;
	case GD_CONFIGURATION:
	  desclen = CD[2];	// Config descriptor includes interface, HID, report and ep descriptors
 388:	62 e2       	ldi	r22, 0x22	; 34
 38a:	70 e0       	ldi	r23, 0x00	; 0
      pDdata = CD;
	  break;
 38c:	1b c0       	rjmp	.+54     	; 0x3c4 <send_descriptor+0x76>
	case GD_STRING:
	  desclen = strDesc[SUD[wValueL]][0];   // wValueL=string index, array[0] is the length
 38e:	40 91 b2 03 	lds	r20, 0x03B2	; 0x8003b2 <SUD+0x2>
 392:	20 e4       	ldi	r18, 0x40	; 64
 394:	42 9f       	mul	r20, r18
 396:	a0 01       	movw	r20, r0
 398:	11 24       	eor	r1, r1
 39a:	fa 01       	movw	r30, r20
 39c:	e8 5b       	subi	r30, 0xB8	; 184
 39e:	fd 4f       	sbci	r31, 0xFD	; 253
 3a0:	60 81       	ld	r22, Z
 3a2:	70 e0       	ldi	r23, 0x00	; 0
      pDdata = strDesc[SUD[wValueL]];       // point to first array element
 3a4:	af 01       	movw	r20, r30
	  break;
 3a6:	0e c0       	rjmp	.+28     	; 0x3c4 <send_descriptor+0x76>
	case GD_HID:
	  desclen = CD[18];
	  pDdata = &CD[18];
 3a8:	45 e8       	ldi	r20, 0x85	; 133
 3aa:	53 e0       	ldi	r21, 0x03	; 3
	case GD_STRING:
	  desclen = strDesc[SUD[wValueL]][0];   // wValueL=string index, array[0] is the length
      pDdata = strDesc[SUD[wValueL]];       // point to first array element
	  break;
	case GD_HID:
	  desclen = CD[18];
 3ac:	69 e0       	ldi	r22, 0x09	; 9
 3ae:	70 e0       	ldi	r23, 0x00	; 0
	  pDdata = &CD[18];
      break;
 3b0:	09 c0       	rjmp	.+18     	; 0x3c4 <send_descriptor+0x76>
	case GD_REPORT:
	  desclen = CD[25];
      pDdata = RepD;
 3b2:	48 e4       	ldi	r20, 0x48	; 72
 3b4:	53 e0       	ldi	r21, 0x03	; 3
	case GD_HID:
	  desclen = CD[18];
	  pDdata = &CD[18];
      break;
	case GD_REPORT:
	  desclen = CD[25];
 3b6:	6b e2       	ldi	r22, 0x2B	; 43
 3b8:	70 e0       	ldi	r23, 0x00	; 0
      pDdata = RepD;
      break;
 3ba:	04 c0       	rjmp	.+8      	; 0x3c4 <send_descriptor+0x76>
  reqlen = SUD[wLengthL] + 256*SUD[wLengthH];	// 16-bit
  switch (SUD[wValueH])			// wValueH is descriptor type
  {
	case GD_DEVICE:
      desclen = DD[0];	// descriptor length
      pDdata = DD;
 3bc:	45 e9       	ldi	r20, 0x95	; 149
 3be:	53 e0       	ldi	r21, 0x03	; 3
  desclen = 0;					// check for zero as error condition (no case statements satisfied)
  reqlen = SUD[wLengthL] + 256*SUD[wLengthH];	// 16-bit
  switch (SUD[wValueH])			// wValueH is descriptor type
  {
	case GD_DEVICE:
      desclen = DD[0];	// descriptor length
 3c0:	62 e1       	ldi	r22, 0x12	; 18
 3c2:	70 e0       	ldi	r23, 0x00	; 0
	case GD_REPORT:
	  desclen = CD[25];
      pDdata = RepD;
      break;
  }
  if (desclen !=0 )                   // one of the case statements above filled in a value
 3c4:	61 15       	cp	r22, r1
 3c6:	71 05       	cpc	r23, r1
 3c8:	61 f0       	breq	.+24     	; 0x3e2 <send_descriptor+0x94>
  {
    sendlen = (reqlen <= desclen) ? reqlen : desclen; // send the smaller of requested and available
 3ca:	eb 01       	movw	r28, r22
 3cc:	86 17       	cp	r24, r22
 3ce:	97 07       	cpc	r25, r23
 3d0:	08 f4       	brcc	.+2      	; 0x3d4 <send_descriptor+0x86>
 3d2:	ec 01       	movw	r28, r24
	writebytes(rEP0FIFO,sendlen,pDdata);
 3d4:	6c 2f       	mov	r22, r28
 3d6:	80 e0       	ldi	r24, 0x00	; 0
 3d8:	1d df       	rcall	.-454    	; 0x214 <writebytes>
	wregAS(rEP0BC,sendlen);   // load EP0BC to arm the EP0-IN transfer & ACKSTAT
 3da:	6c 2f       	mov	r22, r28
 3dc:	88 e2       	ldi	r24, 0x28	; 40
 3de:	cd de       	rcall	.-614    	; 0x17a <wregAS>
 3e0:	03 c0       	rjmp	.+6      	; 0x3e8 <send_descriptor+0x9a>
  }
  else
    STALL_EP0  // none of the descriptor types match
 3e2:	63 e2       	ldi	r22, 0x23	; 35
 3e4:	88 e4       	ldi	r24, 0x48	; 72
 3e6:	b7 de       	rcall	.-658    	; 0x156 <wreg>
}
 3e8:	df 91       	pop	r29
 3ea:	cf 91       	pop	r28
 3ec:	08 95       	ret

000003ee <feature>:
// There are two set/clear feature requests:
//	To a DEVICE: 	Remote Wakeup (RWU).
//  	To an ENDPOINT:	Stall (EP3 only for this app)
//
void feature(unsigned char sc)
{
 3ee:	cf 93       	push	r28
 3f0:	c8 2f       	mov	r28, r24
  unsigned char mask;
  if((SUD[bmRequestType]==0x02)	// dir=h->p, recipient = ENDPOINT
 3f2:	80 91 b0 03 	lds	r24, 0x03B0	; 0x8003b0 <SUD>
 3f6:	82 30       	cpi	r24, 0x02	; 2
 3f8:	f1 f4       	brne	.+60     	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
	&&  (SUD[wValueL]==0x00)	// wValueL is feature selector, 00 is EP Halt
 3fa:	90 91 b2 03 	lds	r25, 0x03B2	; 0x8003b2 <SUD+0x2>
 3fe:	91 11       	cpse	r25, r1
 400:	1a c0       	rjmp	.+52     	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
	&&  (SUD[wIndexL]==0x83))	// wIndexL is endpoint number IN3=83
 402:	90 91 b4 03 	lds	r25, 0x03B4	; 0x8003b4 <SUD+0x4>
 406:	93 38       	cpi	r25, 0x83	; 131
 408:	b1 f4       	brne	.+44     	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
  {
    mask=rreg(rEPSTALLS);   // read existing bits
 40a:	88 e4       	ldi	r24, 0x48	; 72
 40c:	c8 de       	rcall	.-624    	; 0x19e <rreg>
    if(sc == 1)               // set_feature
 40e:	c1 30       	cpi	r28, 0x01	; 1
 410:	31 f4       	brne	.+12     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
    {
      mask += bmSTLEP3IN;       // Halt EP3IN
 412:	c0 e1       	ldi	r28, 0x10	; 16
 414:	c8 0f       	add	r28, r24
      ep3stall=1;
 416:	81 e0       	ldi	r24, 0x01	; 1
 418:	80 93 ae 03 	sts	0x03AE, r24	; 0x8003ae <ep3stall>
 41c:	07 c0       	rjmp	.+14     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
    }
    else                        // clear_feature
    {
      mask &= ~bmSTLEP3IN;      // UnHalt EP3IN
 41e:	c8 2f       	mov	r28, r24
 420:	cf 7e       	andi	r28, 0xEF	; 239
      ep3stall=0;
 422:	10 92 ae 03 	sts	0x03AE, r1	; 0x8003ae <ep3stall>
      wreg(rCLRTOGS,bmCTGEP3IN);  // clear the EP3 data toggle
 426:	60 e1       	ldi	r22, 0x10	; 16
 428:	80 e5       	ldi	r24, 0x50	; 80
 42a:	95 de       	rcall	.-726    	; 0x156 <wreg>
    }
    wreg(rEPSTALLS,(mask|bmACKSTAT)); // Don't use wregAS for this--directly writing the ACKSTAT bit
 42c:	6c 2f       	mov	r22, r28
 42e:	60 64       	ori	r22, 0x40	; 64
 430:	88 e4       	ldi	r24, 0x48	; 72
 432:	91 de       	rcall	.-734    	; 0x156 <wreg>
 434:	0f c0       	rjmp	.+30     	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
  }
  else if ((SUD[bmRequestType]==0x00)	// dir=h->p, recipient = DEVICE
 436:	81 11       	cpse	r24, r1
 438:	0a c0       	rjmp	.+20     	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
	&&  (SUD[wValueL]==0x01))	// wValueL is feature selector, 01 is Device_Remote_Wakeup
 43a:	80 91 b2 03 	lds	r24, 0x03B2	; 0x8003b2 <SUD+0x2>
 43e:	81 30       	cpi	r24, 0x01	; 1
 440:	31 f4       	brne	.+12     	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
  {
    RWU_enabled = sc<<1;	// =2 for set, =0 for clear feature. The shift puts it in the get_status bit position.
 442:	cc 0f       	add	r28, r28
 444:	c0 93 ac 03 	sts	0x03AC, r28	; 0x8003ac <RWU_enabled>
    rregAS(rFNADDR);		// dummy read to set ACKSTAT
 448:	88 e9       	ldi	r24, 0x98	; 152
 44a:	ba de       	rcall	.-652    	; 0x1c0 <rregAS>
  }
  else STALL_EP0
 44c:	03 c0       	rjmp	.+6      	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
 44e:	63 e2       	ldi	r22, 0x23	; 35
 450:	88 e4       	ldi	r24, 0x48	; 72
 452:	81 de       	rcall	.-766    	; 0x156 <wreg>
}
 454:	cf 91       	pop	r28
 456:	08 95       	ret

00000458 <get_status>:

void get_status()
{
unsigned char testbyte;
  testbyte=SUD[bmRequestType];
 458:	80 91 b0 03 	lds	r24, 0x03B0	; 0x8003b0 <SUD>
  switch(testbyte)
 45c:	81 38       	cpi	r24, 0x81	; 129
 45e:	81 f0       	breq	.+32     	; 0x480 <get_status+0x28>
 460:	82 38       	cpi	r24, 0x82	; 130
 462:	c1 f0       	breq	.+48     	; 0x494 <get_status+0x3c>
 464:	80 38       	cpi	r24, 0x80	; 128
 466:	41 f5       	brne	.+80     	; 0x4b8 <get_status+0x60>
  {
    case 0x80: 			// directed to DEVICE
      wreg(rEP0FIFO,(RWU_enabled+1));	// first byte is 000000rs where r=enabled for RWU and s=self-powered.
 468:	60 91 ac 03 	lds	r22, 0x03AC	; 0x8003ac <RWU_enabled>
 46c:	6f 5f       	subi	r22, 0xFF	; 255
 46e:	80 e0       	ldi	r24, 0x00	; 0
 470:	72 de       	rcall	.-796    	; 0x156 <wreg>
      wreg(rEP0FIFO,0x00);		// second byte is always 0
 472:	60 e0       	ldi	r22, 0x00	; 0
 474:	80 e0       	ldi	r24, 0x00	; 0
 476:	6f de       	rcall	.-802    	; 0x156 <wreg>
      wregAS(rEP0BC,2); 		// load byte count, arm the IN transfer, ACK the status stage of the CTL transfer
 478:	62 e0       	ldi	r22, 0x02	; 2
 47a:	88 e2       	ldi	r24, 0x28	; 40
 47c:	7e ce       	rjmp	.-772    	; 0x17a <wregAS>
      break;
    case 0x81: 			// directed to INTERFACE
      wreg(rEP0FIFO,0x00);		// this one is easy--two zero bytes
 47e:	08 95       	ret
 480:	60 e0       	ldi	r22, 0x00	; 0
 482:	80 e0       	ldi	r24, 0x00	; 0
      wreg(rEP0FIFO,0x00);
 484:	68 de       	rcall	.-816    	; 0x156 <wreg>
 486:	60 e0       	ldi	r22, 0x00	; 0
 488:	80 e0       	ldi	r24, 0x00	; 0
      wregAS(rEP0BC,2); 		// load byte count, arm the IN transfer, ACK the status stage of the CTL transfer
 48a:	65 de       	rcall	.-822    	; 0x156 <wreg>
 48c:	62 e0       	ldi	r22, 0x02	; 2
 48e:	88 e2       	ldi	r24, 0x28	; 40
 490:	74 ce       	rjmp	.-792    	; 0x17a <wregAS>
      break;
 492:	08 95       	ret
    case 0x82: 			// directed to ENDPOINT
      if(SUD[wIndexL] == 0x83)		// We only reported ep3, so it's the only one the host can stall IN3=83
 494:	80 91 b4 03 	lds	r24, 0x03B4	; 0x8003b4 <SUD+0x4>
 498:	83 38       	cpi	r24, 0x83	; 131
      {
        wreg(rEP0FIFO,ep3stall);	// first byte is 0000000h where h is the halt (stall) bit
 49a:	59 f4       	brne	.+22     	; 0x4b2 <get_status+0x5a>
 49c:	60 91 ae 03 	lds	r22, 0x03AE	; 0x8003ae <ep3stall>
        wreg(rEP0FIFO,0x00);		// second byte is always 0
 4a0:	80 e0       	ldi	r24, 0x00	; 0
 4a2:	59 de       	rcall	.-846    	; 0x156 <wreg>
 4a4:	60 e0       	ldi	r22, 0x00	; 0
        wregAS(rEP0BC,2); 		// load byte count, arm the IN transfer, ACK the status stage of the CTL transfer
 4a6:	80 e0       	ldi	r24, 0x00	; 0
 4a8:	56 de       	rcall	.-852    	; 0x156 <wreg>
 4aa:	62 e0       	ldi	r22, 0x02	; 2
        break;
 4ac:	88 e2       	ldi	r24, 0x28	; 40
      }
      else
        STALL_EP0		// Host tried to stall an invalid endpoint (not 3)
 4ae:	65 ce       	rjmp	.-822    	; 0x17a <wregAS>
 4b0:	08 95       	ret
 4b2:	63 e2       	ldi	r22, 0x23	; 35
 4b4:	88 e4       	ldi	r24, 0x48	; 72
    default:
      STALL_EP0		// don't recognize the request
 4b6:	4f de       	rcall	.-866    	; 0x156 <wreg>
 4b8:	63 e2       	ldi	r22, 0x23	; 35
 4ba:	88 e4       	ldi	r24, 0x48	; 72
 4bc:	4c ce       	rjmp	.-872    	; 0x156 <wreg>
 4be:	08 95       	ret

000004c0 <set_interface>:
}

void set_interface()	// All we accept are Interface=0 and AlternateSetting=0, otherwise send STALL
{
unsigned char dumval;
  if((SUD[wValueL] == 0)		// wValueL=Alternate Setting index
 4c0:	80 91 b2 03 	lds	r24, 0x03B2	; 0x8003b2 <SUD+0x2>
 4c4:	81 11       	cpse	r24, r1
 4c6:	07 c0       	rjmp	.+14     	; 0x4d6 <set_interface+0x16>
	&&(SUD[wIndexL] == 0))		// wIndexL=Interface index
 4c8:	80 91 b4 03 	lds	r24, 0x03B4	; 0x8003b4 <SUD+0x4>
 4cc:	81 11       	cpse	r24, r1
 4ce:	03 c0       	rjmp	.+6      	; 0x4d6 <set_interface+0x16>
    dumval=rregAS(rFNADDR);	// dummy read to set the ACKSTAT bit
 4d0:	88 e9       	ldi	r24, 0x98	; 152
 4d2:	76 ce       	rjmp	.-788    	; 0x1c0 <rregAS>
 4d4:	08 95       	ret
  else
    STALL_EP0
 4d6:	63 e2       	ldi	r22, 0x23	; 35
 4d8:	88 e4       	ldi	r24, 0x48	; 72
 4da:	3d ce       	rjmp	.-902    	; 0x156 <wreg>
 4dc:	08 95       	ret

000004de <get_interface>:
}

void get_interface()	// Check for Interface=0, always report AlternateSetting=0
{
  if(SUD[wIndexL] == 0)		// wIndexL=Interface index
 4de:	80 91 b4 03 	lds	r24, 0x03B4	; 0x8003b4 <SUD+0x4>
 4e2:	81 11       	cpse	r24, r1
 4e4:	06 c0       	rjmp	.+12     	; 0x4f2 <get_interface+0x14>
  {
    wreg(rEP0FIFO,0);		// AS=0
 4e6:	60 e0       	ldi	r22, 0x00	; 0
 4e8:	36 de       	rcall	.-916    	; 0x156 <wreg>
    wregAS(rEP0BC,1);		// send one byte, ACKSTAT
 4ea:	61 e0       	ldi	r22, 0x01	; 1
 4ec:	88 e2       	ldi	r24, 0x28	; 40
 4ee:	45 ce       	rjmp	.-886    	; 0x17a <wregAS>
 4f0:	08 95       	ret
  }
  else
    STALL_EP0
 4f2:	63 e2       	ldi	r22, 0x23	; 35
 4f4:	88 e4       	ldi	r24, 0x48	; 72
 4f6:	2f ce       	rjmp	.-930    	; 0x156 <wreg>
 4f8:	08 95       	ret

000004fa <get_configuration>:
}

void get_configuration()
{
  wreg(rEP0FIFO,configval);         // Send the config value
 4fa:	60 91 ab 03 	lds	r22, 0x03AB	; 0x8003ab <configval>
 4fe:	80 e0       	ldi	r24, 0x00	; 0
 500:	2a de       	rcall	.-940    	; 0x156 <wreg>
  wregAS(rEP0BC,1);
 502:	61 e0       	ldi	r22, 0x01	; 1
 504:	88 e2       	ldi	r24, 0x28	; 40
 506:	39 ce       	rjmp	.-910    	; 0x17a <wregAS>
 508:	08 95       	ret

0000050a <set_configuration>:
}

void set_configuration()
{
  configval =SUD[wValueL];           // Store the config value
 50a:	80 91 b2 03 	lds	r24, 0x03B2	; 0x8003b2 <SUD+0x2>
 50e:	80 93 ab 03 	sts	0x03AB, r24	; 0x8003ab <configval>
  if(configval != 0)                // If we are configured,
 512:	88 23       	and	r24, r24
 514:	31 f0       	breq	.+12     	; 0x522 <set_configuration+0x18>
    SETBIT(rUSBIEN,bmSUSPIE);       // start looking for SUSPEND interrupts
 516:	80 e7       	ldi	r24, 0x70	; 112
 518:	42 de       	rcall	.-892    	; 0x19e <rreg>
 51a:	68 2f       	mov	r22, r24
 51c:	60 61       	ori	r22, 0x10	; 16
 51e:	80 e7       	ldi	r24, 0x70	; 112
 520:	1a de       	rcall	.-972    	; 0x156 <wreg>
  rregAS(rFNADDR);                  // dummy read to set the ACKSTAT bit
 522:	88 e9       	ldi	r24, 0x98	; 152
 524:	4d ce       	rjmp	.-870    	; 0x1c0 <rregAS>
 526:	08 95       	ret

00000528 <std_request>:
 528:	80 91 b1 03 	lds	r24, 0x03B1	; 0x8003b1 <SUD+0x1>
}

void std_request()
{
  switch(SUD[bRequest])
 52c:	90 e0       	ldi	r25, 0x00	; 0
 52e:	8c 30       	cpi	r24, 0x0C	; 12
 530:	91 05       	cpc	r25, r1
 532:	d8 f4       	brcc	.+54     	; 0x56a <std_request+0x42>
 534:	fc 01       	movw	r30, r24
 536:	88 27       	eor	r24, r24
 538:	ee 58       	subi	r30, 0x8E	; 142
 53a:	ff 4f       	sbci	r31, 0xFF	; 255
 53c:	8f 4f       	sbci	r24, 0xFF	; 255
 53e:	13 c1       	rjmp	.+550    	; 0x766 <__tablejump2__>
  {
	case SR_GET_DESCRIPTOR:
	  send_descriptor();
 540:	06 cf       	rjmp	.-500    	; 0x34e <send_descriptor>
 542:	08 95       	ret
	   break;
	case SR_SET_FEATURE:
	  feature(1);
 544:	81 e0       	ldi	r24, 0x01	; 1
 546:	53 cf       	rjmp	.-346    	; 0x3ee <feature>
	  break;
 548:	08 95       	ret
	case SR_CLEAR_FEATURE:
	  feature(0);
 54a:	80 e0       	ldi	r24, 0x00	; 0
 54c:	50 cf       	rjmp	.-352    	; 0x3ee <feature>
	  break;
 54e:	08 95       	ret
    case SR_GET_STATUS:	
	  get_status();
 550:	83 cf       	rjmp	.-250    	; 0x458 <get_status>
	  break;
	case SR_SET_INTERFACE:
	  set_interface();
 552:	08 95       	ret
	  break;
 554:	b5 cf       	rjmp	.-150    	; 0x4c0 <set_interface>
	case SR_GET_INTERFACE:
	  get_interface();
 556:	08 95       	ret
	  break;
 558:	c2 cf       	rjmp	.-124    	; 0x4de <get_interface>
	case SR_GET_CONFIGURATION:
	  get_configuration();
 55a:	08 95       	ret
 55c:	ce cf       	rjmp	.-100    	; 0x4fa <get_configuration>
	  break;
	case SR_SET_CONFIGURATION:
	  set_configuration();
 55e:	08 95       	ret
 560:	d4 cf       	rjmp	.-88     	; 0x50a <set_configuration>
	  break;
 562:	08 95       	ret
	case SR_SET_ADDRESS:
	  rregAS(rFNADDR);
 564:	88 e9       	ldi	r24, 0x98	; 152
 566:	2c ce       	rjmp	.-936    	; 0x1c0 <rregAS>
 568:	08 95       	ret
	  break;  // discard return value
 56a:	63 e2       	ldi	r22, 0x23	; 35
	default: 
	  STALL_EP0
 56c:	88 e4       	ldi	r24, 0x48	; 72
 56e:	f3 cd       	rjmp	.-1050   	; 0x156 <wreg>
 570:	08 95       	ret

00000572 <class_request>:
 572:	63 e2       	ldi	r22, 0x23	; 35
 574:	88 e4       	ldi	r24, 0x48	; 72
  }
}

void class_request()
{
  STALL_EP0
 576:	ef cd       	rjmp	.-1058   	; 0x156 <wreg>
 578:	08 95       	ret

0000057a <vendor_request>:
}

void vendor_request()
{
  STALL_EP0
 57a:	63 e2       	ldi	r22, 0x23	; 35
 57c:	88 e4       	ldi	r24, 0x48	; 72
 57e:	eb cd       	rjmp	.-1066   	; 0x156 <wreg>
 580:	08 95       	ret

00000582 <do_SETUP>:
}

void do_SETUP()
{
  readbytes(rSUDFIFO,8,SUD);          // got a SETUP packet. Read 8 SETUP bytes
 582:	40 eb       	ldi	r20, 0xB0	; 176
 584:	53 e0       	ldi	r21, 0x03	; 3
 586:	68 e0       	ldi	r22, 0x08	; 8
 588:	80 e2       	ldi	r24, 0x20	; 32
 58a:	2c de       	rcall	.-936    	; 0x1e4 <readbytes>
  switch(SUD[bmRequestType] & 0x60)     // Parse the SETUP packet. For request type, look only at b6&b5
 58c:	80 91 b0 03 	lds	r24, 0x03B0	; 0x8003b0 <SUD>
 590:	80 76       	andi	r24, 0x60	; 96
 592:	80 32       	cpi	r24, 0x20	; 32
 594:	31 f0       	breq	.+12     	; 0x5a2 <do_SETUP+0x20>
 596:	80 34       	cpi	r24, 0x40	; 64
 598:	31 f0       	breq	.+12     	; 0x5a6 <do_SETUP+0x24>
 59a:	81 11       	cpse	r24, r1
  {
    case 0x00:
	  std_request();
 59c:	06 c0       	rjmp	.+12     	; 0x5aa <do_SETUP+0x28>
	  break;
 59e:	c4 cf       	rjmp	.-120    	; 0x528 <std_request>
	case 0x20:
	  class_request();
 5a0:	08 95       	ret
	  break;  // just a stub in this program
 5a2:	e7 cf       	rjmp	.-50     	; 0x572 <class_request>
	case 0x40:
	  vendor_request();
 5a4:	08 95       	ret
	  break;  // just a stub in this program
 5a6:	e9 cf       	rjmp	.-46     	; 0x57a <vendor_request>
	default:
	  STALL_EP0                       // unrecognized request type
 5a8:	08 95       	ret
 5aa:	63 e2       	ldi	r22, 0x23	; 35
 5ac:	88 e4       	ldi	r24, 0x48	; 72
 5ae:	d3 cd       	rjmp	.-1114   	; 0x156 <wreg>
 5b0:	08 95       	ret

000005b2 <do_IN3>:
}

// Send keyboard characters over Endpoint 3-IN
void do_IN3()
{
  if (inhibit_send == 0x01)
 5b2:	80 91 bc 03 	lds	r24, 0x03BC	; 0x8003bc <inhibit_send>
 5b6:	81 30       	cpi	r24, 0x01	; 1
 5b8:	51 f4       	brne	.+20     	; 0x5ce <do_IN3+0x1c>
  {
    wreg(rEP3INFIFO,0);			// send the "keys up" code
 5ba:	60 e0       	ldi	r22, 0x00	; 0
 5bc:	88 e1       	ldi	r24, 0x18	; 24
 5be:	cb dd       	rcall	.-1130   	; 0x156 <wreg>
    wreg(rEP3INFIFO,0);
 5c0:	60 e0       	ldi	r22, 0x00	; 0
 5c2:	88 e1       	ldi	r24, 0x18	; 24
 5c4:	c8 dd       	rcall	.-1136   	; 0x156 <wreg>
    wreg(rEP3INFIFO,0);
 5c6:	60 e0       	ldi	r22, 0x00	; 0
 5c8:	88 e1       	ldi	r24, 0x18	; 24
 5ca:	c5 dd       	rcall	.-1142   	; 0x156 <wreg>
 5cc:	47 c0       	rjmp	.+142    	; 0x65c <do_IN3+0xaa>
  }
  else
  if (send3zeros == 0x01)                         // precede every keycode with the "no keys" code
 5ce:	80 91 bb 03 	lds	r24, 0x03BB	; 0x8003bb <send3zeros>
 5d2:	81 30       	cpi	r24, 0x01	; 1
  {
    wreg(rEP3INFIFO,0);			// send the "keys up" code
 5d4:	61 f4       	brne	.+24     	; 0x5ee <do_IN3+0x3c>
 5d6:	60 e0       	ldi	r22, 0x00	; 0
 5d8:	88 e1       	ldi	r24, 0x18	; 24
    wreg(rEP3INFIFO,0);
 5da:	bd dd       	rcall	.-1158   	; 0x156 <wreg>
 5dc:	60 e0       	ldi	r22, 0x00	; 0
 5de:	88 e1       	ldi	r24, 0x18	; 24
    wreg(rEP3INFIFO,0);
 5e0:	ba dd       	rcall	.-1164   	; 0x156 <wreg>
 5e2:	60 e0       	ldi	r22, 0x00	; 0
 5e4:	88 e1       	ldi	r24, 0x18	; 24
 5e6:	b7 dd       	rcall	.-1170   	; 0x156 <wreg>
    send3zeros=0;                           // next time through this function send the keycode
 5e8:	10 92 bb 03 	sts	0x03BB, r1	; 0x8003bb <send3zeros>
 5ec:	37 c0       	rjmp	.+110    	; 0x65c <do_IN3+0xaa>
  }
  else
  {
    send3zeros=1;
 5ee:	81 e0       	ldi	r24, 0x01	; 1
 5f0:	80 93 bb 03 	sts	0x03BB, r24	; 0x8003bb <send3zeros>
    wreg(rEP3INFIFO,Message[msgidx++]);	// load the next keystroke (3 bytes)
 5f4:	e0 91 ad 03 	lds	r30, 0x03AD	; 0x8003ad <msgidx>
 5f8:	8e 0f       	add	r24, r30
 5fa:	80 93 ad 03 	sts	0x03AD, r24	; 0x8003ad <msgidx>
 5fe:	f0 e0       	ldi	r31, 0x00	; 0
 600:	e0 50       	subi	r30, 0x00	; 0
 602:	fe 4f       	sbci	r31, 0xFE	; 254
 604:	60 81       	ld	r22, Z
 606:	88 e1       	ldi	r24, 0x18	; 24
 608:	a6 dd       	rcall	.-1204   	; 0x156 <wreg>
    wreg(rEP3INFIFO,Message[msgidx++]);
 60a:	e0 91 ad 03 	lds	r30, 0x03AD	; 0x8003ad <msgidx>
 60e:	81 e0       	ldi	r24, 0x01	; 1
 610:	8e 0f       	add	r24, r30
 612:	80 93 ad 03 	sts	0x03AD, r24	; 0x8003ad <msgidx>
 616:	f0 e0       	ldi	r31, 0x00	; 0
 618:	e0 50       	subi	r30, 0x00	; 0
 61a:	fe 4f       	sbci	r31, 0xFE	; 254
 61c:	60 81       	ld	r22, Z
 61e:	88 e1       	ldi	r24, 0x18	; 24
 620:	9a dd       	rcall	.-1228   	; 0x156 <wreg>
    wreg(rEP3INFIFO,Message[msgidx++]);
 622:	e0 91 ad 03 	lds	r30, 0x03AD	; 0x8003ad <msgidx>
 626:	81 e0       	ldi	r24, 0x01	; 1
 628:	8e 0f       	add	r24, r30
 62a:	80 93 ad 03 	sts	0x03AD, r24	; 0x8003ad <msgidx>
 62e:	f0 e0       	ldi	r31, 0x00	; 0
 630:	e0 50       	subi	r30, 0x00	; 0
 632:	fe 4f       	sbci	r31, 0xFE	; 254
 634:	60 81       	ld	r22, Z
 636:	88 e1       	ldi	r24, 0x18	; 24
 638:	8e dd       	rcall	.-1252   	; 0x156 <wreg>
    if(msgidx >= msglen)                    // check for message wrap
 63a:	90 91 ad 03 	lds	r25, 0x03AD	; 0x8003ad <msgidx>
 63e:	80 91 b8 03 	lds	r24, 0x03B8	; 0x8003b8 <msglen>
    {
      msgidx = 0;
 642:	98 17       	cp	r25, r24
 644:	58 f0       	brcs	.+22     	; 0x65c <do_IN3+0xaa>
      L0_OFF
 646:	10 92 ad 03 	sts	0x03AD, r1	; 0x8003ad <msgidx>
 64a:	80 ea       	ldi	r24, 0xA0	; 160
 64c:	a8 dd       	rcall	.-1200   	; 0x19e <rreg>
 64e:	68 2f       	mov	r22, r24
 650:	6e 7f       	andi	r22, 0xFE	; 254
 652:	80 ea       	ldi	r24, 0xA0	; 160
      inhibit_send=1;                     // send the string once per pushbutton press
 654:	80 dd       	rcall	.-1280   	; 0x156 <wreg>
 656:	81 e0       	ldi	r24, 0x01	; 1
 658:	80 93 bc 03 	sts	0x03BC, r24	; 0x8003bc <inhibit_send>
    }
  }
  wreg(rEP3INBC,3);				// arm it
 65c:	63 e0       	ldi	r22, 0x03	; 3
 65e:	80 e4       	ldi	r24, 0x40	; 64
 660:	7a cd       	rjmp	.-1292   	; 0x156 <wreg>
 662:	08 95       	ret

00000664 <service_irqs>:
}

void service_irqs()
{
 664:	cf 93       	push	r28
 666:	df 93       	push	r29
unsigned char itest1,itest2;

  itest1 = rreg(rEPIRQ);            // Check the EPIRQ bits
 668:	88 e5       	ldi	r24, 0x58	; 88
 66a:	99 dd       	rcall	.-1230   	; 0x19e <rreg>
 66c:	c8 2f       	mov	r28, r24
  itest2 = rreg(rUSBIRQ);           // Check the USBIRQ bits
 66e:	88 e6       	ldi	r24, 0x68	; 104
 670:	96 dd       	rcall	.-1236   	; 0x19e <rreg>
 672:	d8 2f       	mov	r29, r24
  if(itest1 & bmSUDAVIRQ)
 674:	c5 ff       	sbrs	r28, 5
 676:	04 c0       	rjmp	.+8      	; 0x680 <service_irqs+0x1c>
  {
    wreg(rEPIRQ,bmSUDAVIRQ);     // clear the SUDAV IRQ
 678:	60 e2       	ldi	r22, 0x20	; 32
 67a:	88 e5       	ldi	r24, 0x58	; 88
    do_SETUP();
 67c:	6c dd       	rcall	.-1320   	; 0x156 <wreg>
 67e:	81 df       	rcall	.-254    	; 0x582 <do_SETUP>
  }
  if(itest1 & bmIN3BAVIRQ)          // Was an EP3-IN packet just dispatched to the host?
 680:	c4 fd       	sbrc	r28, 4
  {
 	do_IN3();                     // Yes--load another keystroke and arm the endpoint
 682:	97 df       	rcall	.-210    	; 0x5b2 <do_IN3>
 684:	80 91 ab 03 	lds	r24, 0x03AB	; 0x8003ab <configval>
  }                             // NOTE: don't clear the IN3BAVIRQ bit here--loading the EP3-IN byte
  // count register in the do_IN3() function does it.
  if((configval != 0) && (itest2&bmSUSPIRQ))   // HOST suspended bus for 3 msec
 688:	88 23       	and	r24, r24
 68a:	a1 f0       	breq	.+40     	; 0x6b4 <service_irqs+0x50>
 68c:	d4 ff       	sbrs	r29, 4
  {
    wreg(rUSBIRQ,(bmSUSPIRQ+bmBUSACTIRQ));  // clear the IRQ and bus activity IRQ
 68e:	12 c0       	rjmp	.+36     	; 0x6b4 <service_irqs+0x50>
 690:	64 e1       	ldi	r22, 0x14	; 20
 692:	88 e6       	ldi	r24, 0x68	; 104
    L2_ON                         // turn on the SUSPEND light
 694:	60 dd       	rcall	.-1344   	; 0x156 <wreg>
 696:	80 ea       	ldi	r24, 0xA0	; 160
 698:	82 dd       	rcall	.-1276   	; 0x19e <rreg>
 69a:	68 2f       	mov	r22, r24
 69c:	64 60       	ori	r22, 0x04	; 4
 69e:	80 ea       	ldi	r24, 0xA0	; 160
    L3_OFF                        // turn off blinking light (in case it's on)
 6a0:	5a dd       	rcall	.-1356   	; 0x156 <wreg>
 6a2:	80 ea       	ldi	r24, 0xA0	; 160
 6a4:	7c dd       	rcall	.-1288   	; 0x19e <rreg>
 6a6:	68 2f       	mov	r22, r24
 6a8:	67 7f       	andi	r22, 0xF7	; 247
 6aa:	80 ea       	ldi	r24, 0xA0	; 160
    Suspended=1;                  // signal the main loop
 6ac:	54 dd       	rcall	.-1368   	; 0x156 <wreg>
 6ae:	81 e0       	ldi	r24, 0x01	; 1
  }
  if(rreg(rUSBIRQ) & bmURESIRQ)
 6b0:	80 93 a8 03 	sts	0x03A8, r24	; 0x8003a8 <__data_end>
 6b4:	88 e6       	ldi	r24, 0x68	; 104
 6b6:	73 dd       	rcall	.-1306   	; 0x19e <rreg>
  {
    L1_ON                         // turn the BUS RESET light on
 6b8:	83 ff       	sbrs	r24, 3
 6ba:	0f c0       	rjmp	.+30     	; 0x6da <service_irqs+0x76>
 6bc:	80 ea       	ldi	r24, 0xA0	; 160
 6be:	6f dd       	rcall	.-1314   	; 0x19e <rreg>
 6c0:	68 2f       	mov	r22, r24
    L2_OFF                        // Suspend light off (if on)
 6c2:	62 60       	ori	r22, 0x02	; 2
 6c4:	80 ea       	ldi	r24, 0xA0	; 160
 6c6:	47 dd       	rcall	.-1394   	; 0x156 <wreg>
 6c8:	80 ea       	ldi	r24, 0xA0	; 160
 6ca:	69 dd       	rcall	.-1326   	; 0x19e <rreg>
 6cc:	68 2f       	mov	r22, r24
    wreg(rUSBIRQ,bmURESIRQ);      // clear the IRQ
 6ce:	6b 7f       	andi	r22, 0xFB	; 251
 6d0:	80 ea       	ldi	r24, 0xA0	; 160
 6d2:	41 dd       	rcall	.-1406   	; 0x156 <wreg>
  }
  if(rreg(rUSBIRQ) & bmURESDNIRQ)
 6d4:	68 e0       	ldi	r22, 0x08	; 8
 6d6:	88 e6       	ldi	r24, 0x68	; 104
 6d8:	3e dd       	rcall	.-1412   	; 0x156 <wreg>
 6da:	88 e6       	ldi	r24, 0x68	; 104
 6dc:	60 dd       	rcall	.-1344   	; 0x19e <rreg>
  {
    L1_OFF                        // turn the BUS RESET light off
 6de:	88 23       	and	r24, r24
 6e0:	64 f4       	brge	.+24     	; 0x6fa <service_irqs+0x96>
 6e2:	80 ea       	ldi	r24, 0xA0	; 160
 6e4:	5c dd       	rcall	.-1352   	; 0x19e <rreg>
 6e6:	68 2f       	mov	r22, r24
 6e8:	6d 7f       	andi	r22, 0xFD	; 253
 6ea:	80 ea       	ldi	r24, 0xA0	; 160
 6ec:	34 dd       	rcall	.-1432   	; 0x156 <wreg>
    wreg(rUSBIRQ,bmURESDNIRQ);    // clear the IRQ bit
 6ee:	60 e8       	ldi	r22, 0x80	; 128
 6f0:	88 e6       	ldi	r24, 0x68	; 104
 6f2:	31 dd       	rcall	.-1438   	; 0x156 <wreg>
 6f4:	10 92 a8 03 	sts	0x03A8, r1	; 0x8003a8 <__data_end>
    Suspended = 0;                  // in case we were suspended
 6f8:	b3 dd       	rcall	.-1178   	; 0x260 <EnableIRQs>
	EnableIRQs();                   // ...because a bus reset clears the IE bits
 6fa:	df 91       	pop	r29
 6fc:	cf 91       	pop	r28
  }
 6fe:	08 95       	ret

00000700 <main>:
#define TWENTY_MSEC 14200           // adjust this constant for 20 msec button checks
#define BLINKTIME 25                // blink every 500 msec

int main(void)
{
	initMAX3421();
 700:	b6 dd       	rcall	.-1172   	; 0x26e <initMAX3421>
	while (1)
	{
		if(Suspended)
 702:	80 91 a8 03 	lds	r24, 0x03A8	; 0x8003a8 <__data_end>
		check_for_resume();
 706:	81 11       	cpse	r24, r1
		if (MAX_Int_Pending())
 708:	dc dd       	rcall	.-1096   	; 0x2c2 <check_for_resume>
 70a:	17 de       	rcall	.-978    	; 0x33a <MAX_Int_Pending>
		service_irqs();
 70c:	81 11       	cpse	r24, r1
 70e:	aa df       	rcall	.-172    	; 0x664 <service_irqs>
		msec_timer++;
 710:	80 91 b9 03 	lds	r24, 0x03B9	; 0x8003b9 <msec_timer>
 714:	90 91 ba 03 	lds	r25, 0x03BA	; 0x8003ba <msec_timer+0x1>
 718:	01 96       	adiw	r24, 0x01	; 1
 71a:	90 93 ba 03 	sts	0x03BA, r25	; 0x8003ba <msec_timer+0x1>
 71e:	80 93 b9 03 	sts	0x03B9, r24	; 0x8003b9 <msec_timer>
		if(msec_timer == TWENTY_MSEC)
 722:	88 37       	cpi	r24, 0x78	; 120
 724:	97 43       	sbci	r25, 0x37	; 55
 726:	69 f7       	brne	.-38     	; 0x702 <main+0x2>
		{
			msec_timer=0;
 728:	10 92 ba 03 	sts	0x03BA, r1	; 0x8003ba <msec_timer+0x1>
 72c:	10 92 b9 03 	sts	0x03B9, r1	; 0x8003b9 <msec_timer>
			
			if((rreg(rGPIO) & 0x10) == 0) // Check the pushbutton on GPI-0
 730:	80 ea       	ldi	r24, 0xA0	; 160
 732:	35 dd       	rcall	.-1430   	; 0x19e <rreg>
 734:	84 ff       	sbrs	r24, 4
			{
				inhibit_send = 0x00;      // Tell the "do_IN3" function to send the text string
 736:	10 92 bc 03 	sts	0x03BC, r1	; 0x8003bc <inhibit_send>
				// L0_ON                     // Turn on the SEND light
			}
			blinktimer++;                 // blink the loop active light every half second
 73a:	80 91 a9 03 	lds	r24, 0x03A9	; 0x8003a9 <blinktimer>
 73e:	90 91 aa 03 	lds	r25, 0x03AA	; 0x8003aa <blinktimer+0x1>
 742:	01 96       	adiw	r24, 0x01	; 1
 744:	90 93 aa 03 	sts	0x03AA, r25	; 0x8003aa <blinktimer+0x1>
 748:	80 93 a9 03 	sts	0x03A9, r24	; 0x8003a9 <blinktimer>
			if(blinktimer == BLINKTIME)
 74c:	49 97       	sbiw	r24, 0x19	; 25
 74e:	c9 f6       	brne	.-78     	; 0x702 <main+0x2>
			{
				blinktimer=0;
 750:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <blinktimer+0x1>
 754:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <blinktimer>
				L3_BLINK
 758:	80 ea       	ldi	r24, 0xA0	; 160
 75a:	21 dd       	rcall	.-1470   	; 0x19e <rreg>
 75c:	68 e0       	ldi	r22, 0x08	; 8
 75e:	68 27       	eor	r22, r24
 760:	80 ea       	ldi	r24, 0xA0	; 160
 762:	f9 dc       	rcall	.-1550   	; 0x156 <wreg>
 764:	ce cf       	rjmp	.-100    	; 0x702 <main+0x2>

00000766 <__tablejump2__>:
 766:	ee 0f       	add	r30, r30
 768:	ff 1f       	adc	r31, r31
 76a:	88 1f       	adc	r24, r24
 76c:	8b bf       	out	0x3b, r24	; 59
 76e:	07 90       	elpm	r0, Z+
 770:	f6 91       	elpm	r31, Z
 772:	e0 2d       	mov	r30, r0
 774:	19 94       	eijmp

00000776 <_exit>:
 776:	f8 94       	cli

00000778 <__stop_program>:
 778:	ff cf       	rjmp	.-2      	; 0x778 <__stop_program>
